package com.thisisnotyours.mvvm_recyclerview.response

//edit: 비동기 처리란? (Asynchronous Processing)
//어떤 작업을 실행할 때, 결과가 나올 때까지 기다리지 않고 다른 작업을 수행하고
//결과가 나오면 해당결과를 받아 처리하는 방식.
//이를통해 일반적으로 동기처리 방식에 발생하는 느린 속도와 대기시간을 줄일 수 있음.
//예시-1)
//인터넷에서 데이터를 가져오는 작업을 수행한다면, 네트워크 환경에 따라 결과가 나오기까지 시간이 걸릴 수 있음.
//이때, 비동기 처리를 이용하여 다른작업을 수행하다가(화면에서 로딩바를 보여주거나) 결과가 나오면 해당결과를 받아 처리할 수 있음.
//예시-2)
//파일 다운로드를 수행하는 동안 사용자가 게임을 플레이하거나 동영상을 시청(다른작업 수행)
//예시-3)
//데이터베이스 작업은 (I/O 작업의 일종)
//네트워크에서 데이터를 가져오는 작업과 마찬가지로, 시간이 걸릴 수 있는 작업임.
//1. 데이터베이스 연결
//2. 쿼리 실행
//3. 결과 반환
//4.데이터베이스 연결 해제
//위 작업을 동기적으로 수행하게 된다면, 하나의 작업이 완료되어야 다음 작업을 수행할 수 있기 때문에, 작업 전체가 완료되는 데 까지 많은 시간이 소요될 수 있음.
//그러나 코루틴을 사용하면 이러한 작업을 비동기적으로 수행할 수 있음.
//예를 들어, 데이터베이스 연결 작업을 코루틴으로 비동기적으로 처리하면, 데이터베이스 연결이 완료될 때까지 다른 작업을 수행하다가,
//연결이 완료되면 결과를 받아와서 쿼리를 실행하고, 그 결과를 받아올 때까지 다른 작업을 수행하다가, 최종 결과를 받아와서 필요한 작업을 처리할 수 있음.
//이렇게 함으로써, 하나의 작업이 완료될 때까지 대기하는 대신에, 다른 작업을 수행하면서 효율적으로 시간을 활용할 수 있게 됨.

//I/O(Input/Output)란, 컴퓨터와 주변 기기 또는 파일 시스템과 같은 외부 환경 간의 데이터 흐름을 의미합니다.
// 예를 들어, 디스크에 데이터를 쓰거나 읽는 것, 네트워크로 데이터를 전송하거나 받는 것 등이 모두 I/O 작업에 해당합니다.
// I/O 작업은 보통 디스크나 네트워크 등과 같은 비교적 느린 외부 환경과의 상호작용이기 때문에, 이 작업을 비동기적으로 처리하는 것이 중요합니다.



//edit: 코루틴이란?
//코틀린에서 사용하는 '코루틴(Coroutine)'은 비동기 처리를 쉽게 해주는 기술.
//코루틴은 멀티 쓰레드를 사용하지 않으면서도 비동기 처리를 가능하게 해줌.
//이를 통해 쓰레드를 관리하고, 쓰레드를 사용하여 비동기 처리를 하는것에 비해 간단한 코드작성 가능.
//코루틴은 일반적인 스레드와 다르게 스택을 저장하지 않고 작업을 일시 중단한 다음, (코드 블록의 실행을 일시 중지)
//나중에 다시 시작할 수 있는 기능을 제공함. (가벼운 스레드라고 봐도무관)
//이를통해, 스레드를 생성하고 제거하는 과정에서 발생하는 부하와 자원 소모를 줄일 수 있음.
//안드로이드에서는 코루틴을 사용하여 네트워크 작업이나 데이터베이스 작업들을 비동기적으로 처리하는것이 권장됨.
//이를통해 UI 스레드를 차단하지 않고, 더 나은 사용자 경험을 제공할 수 있음.

//반면에, 일반적인 스레드는 작업이 끝날때까지 계속 실행되며,
//해당 스레드의 작업이 완료되기 전까지는 다른 스레드의 작업을 처리하지 않음.
//반면에, 코루틴은 실행이 중단될 때마다 다른 코루틴으로 제어가 '이동할 수 있음'으로, 보다 효율적으로 작업처리가 가능.
//이러한 이유로 코루틴은 스레드보다 더 경량화 되어있으며. 대규모 애플리케이션에서 더 많은 작업처리가 가능.

//코루틴은 일반적인 스레드와 달리 두가지 개념을 중요하게 다움.
//1. 첫번째는 실행을 일시중지하고 나중에 다시 시작할 수 있는 기능: '일시중단(suspend)'
//2. 두번째는 다른 코루틴으로 제어권을 양도하는 기능: '제어권 이전(yield)'
//따라서 '이동한다'는 것은, 현재 실행중인 코루틴이 실행을 일시 중지하고,
//다른 코루틴으로 제어권을 양도하여 그 코루틴이 실행되는 것을 말함.
//이후에는 다른 코루틴의 실행이 끝나면, 다시 처음 실행을 일시 중지한 코루틴으로 제어권이 넘어가서 그 코루틴이 이어서 실행됨.
//이 과정을 반복하면서 여러개의 코루틴이 동시에 실행될 수 있게 됨.



//edit: !!와 ?
//!!와 ? 연산자는 코틀린에서 사용되는 null 처리 연산자입니다. 이 두 연산자의 의미는 다음과 같습니다.
//? (Safe Call Operator) : 이 연산자는 null 처리를 안전하게 수행할 때 사용됩니다.
//?를 사용하여 변수에 접근하면, 변수가 null인 경우에도 안전하게 처리할 수 있습니다.
//변수가 null이 아닌 경우에만 해당 메서드 또는 속성에 접근합니다.
//예시)
//val length = someString?.length
//여기서 someString이 null이면 length는 null이 됩니다.

//!! (Non-null Assertion Operator) : 이 연산자는 변수가 null이 아니라고 확신할 때 사용됩니다.
//변수에 !!를 사용하면, 변수가 null인 경우 NullPointerException이 발생합니다. 따라서 !!를 사용할 때는 주의가 필요합니다.
//예시)
//val length = someString!!.length
//여기서 someString이 null이면 NullPointerException이 발생합니다.


//다시 코드를 살펴보면:
//val headers: Headers? = response.headers
//val token = headers?.get("Set-Cookie")
//_cookieTokenLiveData.postValue(token!!)

//headers는 null이 될 수 있는 타입인 Headers?로 선언되어 있으며,
//headers?.get("Set-Cookie")는 headers가 null이 아닌 경우에만 get 메서드를 호출합니다.
//token이 null이 아니라고 확신하고, 이 값을 _cookieTokenLiveData에 게시하려면 !!를 사용하여 NullPointerException이 발생하지 않도록 해야 합니다.
//하지만 가능하면 안전한 호출 연산자(?)를 사용하여 null 처리를 하는 것이 좋습니다.



//edit: LiveData
//LiveData 는 Jetpack 아키텍처 컴포넌트의 하나로, 관찰 가능한 데이터 홀더 클래스 임.
//즉, 데이터를 홀딩하고, 데이터의 변화가 있을 때마다 감지하여
//등록된 옵저버(Observer)들에게 자동으로 알려주는 역할을 함.
//LiveData 는 수명주기(LifeCycle)를 인식하기 때문에,
//화면 회전과 같이 액티비티나 프래그먼트의 수명주기에 따라 올바르게 데이터를 관리할 수 있음.
//따라서, LiveData 를 사용하면 액티비티나 프래그먼트에서 복잡한 수명주기 관리 없이도
//데이터의 변경사항을 적절하게 처리할 수 있음.


//edit: viewModelScope.launch
//viewModelScope.launch 는 코루틴에서 실행 가능한 블록을 실행시키는 함수입니다.
// (viewModelScope.launch 함수 내부안에 작성된 코드 블록들을 실행 가능한 블록이라함)
// 이 함수를 호출하면 새로운 코루틴이 생성되어 백그라운드 스레드에서 실행됩니다.
// 이 함수는 백그라운드 스레드에서 실행되기 때문에, UI 스레드가 차단되지 않고 사용자 인터페이스가 유지됩니다.
// 또한, ViewModel 의 생명주기에 맞추어 자동으로 취소되기 때문에, 메모리 릭이나 불필요한 작업을 방지할 수 있습니다.

//즉, viewModelScope.launch { ... } 내부의 코드 블록들이 실행 가능한 블록이며,
// 이 블록 안에서 서버로부터 데이터를 받아오는 등의 작업을 비동기적으로 처리합니다.
// 이때 비동기 처리를 위해 코루틴을 사용하는 것입니다.

// viewModelScope.launch 는 suspend 함수 내에서만 사용 가능합니다.
// 코루틴에서는 suspend 함수를 사용하여 비동기 작업을 수행합니다. 코루틴은 기본적으로 비동기 작업을 처리하기 위한 기술로서,
// 여러 개의 코루틴이 동시에 실행될 수 있습니다. suspend 함수를 호출하면, 현재 실행 중인 코루틴이 일시 중지되고 다른 코루틴이 실행됩니다.
// 일시 중지된 코루틴은 필요한 시점에 다시 실행됩니다.

// 따라서 viewModelScope.launch 는 비동기적으로 실행될 코드를 작성할 때 매우 유용합니다.
// 이 함수를 사용하면 UI 스레드가 차단되지 않으면서 백그라운드에서 비동기 작업을 수행할 수 있습니다.
